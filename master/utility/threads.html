<!DOCTYPE html>
<html>
<head>
<title>threads.pl -- Threading utilities.</title>

<link rel="stylesheet" type="text/css" href="../pldoc.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

</head>
<body>


<h1 class="file"><span style="float:right"></span>threads.pl -- Threading utilities.</h1>

<dl class="tags">
<dt class="keyword-author">author</dt><dd class="keyword-author">- Daniel Be√üler</dd>
<dt class="keyword-license">license</dt><dd class="keyword-license">- BSD</dd>
</dl>

<dl>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="message_queue_materialize/2"><b class="pred">message_queue_materialize</b><var class="arglist">(+Queue, -Term)</var></a> is <b class="det">nondet</b></dt><dd class="defbody">Retrieves and removes <var>Term</var> from queue.
This will block until at least one message is available in the queue
before returning a result or failing.
A choicepoint is created for the next queue element until end_of_stream reached.
It is not ensured that this call is deterministic in case
there is only one message before end_of_stream
(it is deterministic if end_of_stream was already queued
when the last message was retrieved).

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Queue</var></td><td class="argdescr">- a message queue.</td></tr>
<tr><td><var>Term</var></td><td class="argdescr">- queued message</td></tr>
</table>

</dd>
<dt class="keyword-see">See also</dt><dd class="keyword-see">- <a href="https://www.swi-prolog.org/pldoc/man?section=msgqueue">https://www.swi-prolog.org/pldoc/man?section=msgqueue</a></dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="worker_pool_create/1"><b class="pred">worker_pool_create</b><var class="arglist">(+WorkerPool)</var></a> is <b class="det">det</b></dt><dd class="defbody">Same as <a href="threads.html#worker_pool_create/2">worker_pool_create/2</a> with empty options.

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>WorkerPool</var></td><td class="argdescr">- the worker pool name.</td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="worker_pool_create/2"><b class="pred">worker_pool_create</b><var class="arglist">(+WorkerPool, +Options)</var></a> is <b class="det">det</b></dt><dd class="defbody">Creates a new thread pool with worker threads. <var>Options</var> include:

<dl class="termlist">
<dt class="term"><b class="pred">initial_pool_size</b><var class="arglist">(InitialSize)</var></dt><dd>Determines the number of threads initially started. Default is 2.</dd>
</dl>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>WorkerPool</var></td><td class="argdescr">- the worker pool name.</td></tr>
<tr><td><var>Options</var></td><td class="argdescr">- additional options.</td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="worker_pool_start_work/3"><b class="pred">worker_pool_start_work</b><var class="arglist">(+WorkerPool, -WorkID, +WorkerGoal)</var></a> is <b class="det">det</b></dt><dd class="defbody">Schedules a new work goal.
<a href="threads.html#worker_pool_stop_work/2">worker_pool_stop_work/2</a> must be called once the work is done.
This is usually done by wrapping it into a call of <a class="builtin" href="http://www.swi-prolog.org/pldoc/man?predicate=setup_call_cleanup/3">setup_call_cleanup/3</a>.

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>WorkerPool</var></td><td class="argdescr">- the worker pool name.</td></tr>
<tr><td><var>WorkID</var></td><td class="argdescr">- the work ID.</td></tr>
<tr><td><var>WorkerGoal</var></td><td class="argdescr">- the goal of each worker.</td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="worker_pool_join/2"><b class="pred">worker_pool_join</b><var class="arglist">(+PoolID, +WorkID)</var></a> is <b class="det">det</b></dt><dd class="defbody">Block the current thread until work is done.</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="worker_pool_stop_work/2"><b class="pred">worker_pool_stop_work</b><var class="arglist">(+WorkerPool, -WorkID)</var></a> is <b class="det">det</b></dt><dd class="defbody">Unschedule any remaining work associated to <var>WorkID</var>.
This may not immediately shut-down all operations,
but will prevent any more results to be communicated,
and new operations being started.

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>WorkerPool</var></td><td class="argdescr">- the worker pool name.</td></tr>
<tr><td><var>WorkID</var></td><td class="argdescr">- the work ID.</td></tr>
</table>

</dd>
</dl>

</dd>
</dl>

</body>
</html>
